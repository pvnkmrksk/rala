<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#000000">
    <meta name="description" content="English ‚Üí Kannada dictionary. An amateur reversal of V. Krishna's Alar">
    <title>Rala - English to Kannada Dictionary</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="icon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="icon.svg">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 0;
            background: white;
            color: #333;
        }
        
        .header {
            text-align: center;
            padding: 60px 20px 30px;
        }
        
        h1 {
            font-size: 72px;
            font-weight: 600;
            color: #000;
            margin: 0 0 20px;
            letter-spacing: -1px;
            line-height: 1.1;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 8px;
            font-size: 15px;
            line-height: 1.6;
        }
        
        .subtitle-line {
            display: block;
            margin-bottom: 4px;
        }
        
        .sticky-search {
            position: sticky;
            top: 0;
            background: white;
            z-index: 200;
            border-bottom: 1px solid #e0e0e0;
            padding: 20px 20px;
        }
        
        .search-wrapper {
            padding: 0;
        }
        
        .search-container {
            display: flex;
            gap: 8px;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .lang-selector {
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 14px;
            color: #666;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        input[type="text"] {
            flex: 1;
            padding: 12px 16px;
            font-size: 16px;
            border: 1px solid #ddd;
            border-radius: 8px;
            outline: none;
            transition: border-color 0.2s;
        }
        
        input[type="text"]:focus {
            border-color: #000;
        }
        
        .search-button {
            background: #000;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        
        .search-button:hover {
            background: #333;
        }
        
        .search-button svg {
            width: 20px;
            height: 20px;
        }
        
        .status {
            text-align: center;
            padding: 20px;
            color: #666;
        }
        
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 40px;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e0e0e0;
            border-top-color: #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .results-section {
            margin-bottom: 24px;
        }
        
        .section-title {
            font-size: 14px;
            font-weight: 600;
            color: #7f8c8d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .result-card {
            background: white;
            border-radius: 0;
            padding: 20px 0;
            margin-bottom: 0;
            border-bottom: 1px solid #f0f0f0;
            transition: background 0.2s;
        }
        
        .result-card:hover {
            background: #fafafa;
        }
        
        .result-card:last-child {
            border-bottom: none;
        }
        
        .kannada-word {
            font-size: 28px;
            font-weight: 600;
            color: #000;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .audio-button {
            background: transparent;
            border: 1px solid #ddd;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            padding: 0;
            flex-shrink: 0;
        }
        
        .audio-button:hover {
            background: #f5f5f5;
            border-color: #999;
        }
        
        .audio-button:active {
            transform: scale(0.95);
        }
        
        .audio-button svg {
            width: 16px;
            height: 16px;
            color: #666;
        }
        
        .audio-button.playing {
            background: #000;
            border-color: #000;
        }
        
        .audio-button.playing svg {
            color: white;
        }
        
        .phonetic {
            font-size: 14px;
            color: #999;
            font-style: italic;
            margin-bottom: 12px;
        }
        
        .definition {
            margin-bottom: 8px;
            padding-left: 0;
            border-left: none;
        }
        
        .def-type {
            font-size: 11px;
            color: #666;
            background: #f5f5f5;
            padding: 3px 8px;
            border-radius: 4px;
            margin-right: 8px;
            text-transform: uppercase;
            font-weight: 500;
        }
        
        .def-text {
            color: #333;
            line-height: 1.6;
        }
        
        .matched-word {
            background: #fff3cd;
            padding: 1px 4px;
            border-radius: 3px;
        }
        
        .synonym-match {
            font-size: 13px;
            color: #999;
            margin-top: 8px;
            font-style: italic;
        }
        
        .no-results {
            text-align: center;
            padding: 40px;
            color: #95a5a6;
        }
        
        .stats {
            text-align: center;
            font-size: 13px;
            color: #999;
            margin-top: 40px;
            padding: 20px;
        }
        
        .search-info {
            font-size: 14px;
            color: #666;
            margin-bottom: 20px;
            padding: 12px 0;
        }
        
        .tabs-wrapper {
            position: sticky;
            top: 80px;
            background: white;
            z-index: 100;
            border-bottom: 1px solid #e0e0e0;
            padding: 16px 20px;
            margin-bottom: 0;
        }
        
        .tabs {
            display: flex;
            gap: 8px;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .tab {
            padding: 10px 20px;
            border: none;
            background: transparent;
            border-radius: 6px;
            cursor: pointer;
            font-size: 15px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #666;
            font-weight: 500;
        }
        
        .tab.active {
            background: #f5f5f5;
            color: #000;
        }
        
        .tab:hover:not(.active) {
            background: #fafafa;
            color: #000;
        }
        
        .tab.loading {
            opacity: 0.7;
        }
        
        .tab-spinner {
            width: 14px;
            height: 14px;
            border: 2px solid currentColor;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            display: inline-block;
        }
        
        .results-container {
            padding: 20px;
        }
        
        .results-section {
            margin-bottom: 40px;
        }
        
        .section-anchor {
            scroll-margin-top: 80px;
        }
        
        .section-header {
            font-size: 18px;
            font-weight: 600;
            color: #000;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .attribution {
            margin-top: 60px;
            padding: 40px 20px;
            text-align: center;
            font-size: 13px;
            color: #999;
            border-top: 1px solid #e0e0e0;
        }
        
        .attribution a {
            color: #000;
            text-decoration: underline;
        }
        
        .attribution a:hover {
            text-decoration: none;
        }
        
        .footer-links {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 20px;
        }
        
        .footer-links a {
            color: #666;
            text-decoration: none;
        }
        
        .footer-links a:hover {
            color: #000;
        }
        
        .install-prompt {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #000;
            color: white;
            padding: 14px 18px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: none;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
            cursor: pointer;
            font-size: 14px;
            max-width: 320px;
            line-height: 1.4;
        }
        
        .install-prompt.show {
            display: flex;
        }
        
        .install-prompt:hover {
            background: #333;
        }
        
        .install-prompt-header {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .install-prompt svg {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }
        
        .install-prompt .close {
            margin-left: auto;
            opacity: 0.7;
            font-size: 18px;
            line-height: 1;
            cursor: pointer;
        }
        
        .install-prompt .close:hover {
            opacity: 1;
        }
        
        .install-prompt-text {
            font-size: 13px;
            opacity: 0.9;
            margin-top: 4px;
        }
        
        .pwa-info-banner {
            background: #f5f5f5;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 16px;
            margin: 20px;
            font-size: 14px;
            color: #666;
            display: none;
        }
        
        .pwa-info-banner.show {
            display: block;
        }
        
        .pwa-info-banner strong {
            color: #000;
            display: block;
            margin-bottom: 8px;
        }
        
        .pwa-info-banner ul {
            margin: 8px 0;
            padding-left: 20px;
        }
        
        .pwa-info-banner li {
            margin: 4px 0;
        }
        
        .pwa-info-banner .dismiss {
            margin-top: 12px;
            color: #000;
            text-decoration: underline;
            cursor: pointer;
            display: inline-block;
        }
        
        .pwa-info-banner .dismiss:hover {
            text-decoration: none;
        }
        
        @media (max-width: 600px) {
            .install-prompt {
                bottom: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
            }
        }
    </style>
</head>
<body>
    <div id="install-prompt" class="install-prompt">
        <div class="install-prompt-header">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
            </svg>
            <span><strong>Install Rala</strong></span>
            <span class="close" id="install-close">√ó</span>
        </div>
        <div class="install-prompt-text">Install for offline use and faster access</div>
    </div>
    
    <div id="pwa-info-banner" class="pwa-info-banner">
        <strong>üí° Install Rala as an App</strong>
        <p>You can install Rala on your device to use it offline and access it like a native app:</p>
        <ul>
            <li><strong>Desktop:</strong> Look for the install button in your browser's address bar, or click the install prompt below</li>
            <li><strong>Mobile:</strong> Use "Add to Home Screen" from your browser menu</li>
            <li><strong>Benefits:</strong> Works offline, faster loading, app-like experience</li>
        </ul>
        <span class="dismiss" id="pwa-info-dismiss">Got it, dismiss this message</span>
    </div>
    
    <div class="header">
        <h1>‡≤∞‡≤≤</h1>
        <p class="subtitle">
            <span class="subtitle-line">‡≤á‡≤Ç‡≤ó‡≥ç‡≤≤‡≤ø‡≤∑‡≥ç ‡≤ï‡≤®‡≥ç‡≤®‡≤° ‡≤®‡≤ø‡≤ò‡≤Ç‡≤ü‡≥Å. ‡≤∂‡≥ç‡≤∞‡≥Ä. ‡≤µ‡≤ø. ‡≤ï‡≥É‡≤∑‡≥ç‡≤£ ‡≤Ö‡≤µ‡≤∞ "‡≤Ö‡≤≤‡≤∞‡≥ç" ‡≤® ‡≤π‡≤µ‡≥ç‡≤Ø‡≤æ‡≤∏‡≤ø ‡≤π‡≤ø‡≤Æ‡≥ç‡≤Æ‡≥Å‡≤ñ</span>
            <span class="subtitle-line">"Rala" English ‚Üí Kannada dictionary. An amateur reversal of V. Krishna's Alar</span>
        </p>
    </div>
    
    <div class="sticky-search">
        <div class="search-wrapper" id="search-wrapper">
            <div class="search-container">
                <input type="text" id="search-input" placeholder="Search English word..." autofocus>
                <button class="search-button" id="search-button">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"></circle>
                        <path d="m21 21-4.35-4.35"></path>
                    </svg>
                </button>
            </div>
        </div>
    </div>
    
    <div id="app">
        <div class="loading">
            <div class="spinner"></div>
            <p>Loading dictionary from GitHub...</p>
        </div>
    </div>
    
    <footer class="attribution">
        <p>
            <strong>Rala (‡≤∞‡≤≤)</strong> = Reverse <a href="https://alar.ink" target="_blank">Alar</a> ¬∑ 
            Dictionary data by <a href="https://alar.ink" target="_blank">V. Krishna</a> ¬∑ 
            Licensed under <a href="https://opendatacommons.org/licenses/odbl/" target="_blank">ODC-ODbL</a> ¬∑ 
            <a href="https://github.com/alar-dict/data" target="_blank">Source Data</a>
        </p>
        <div class="footer-links">
            <a href="https://github.com/alar-dict/data">Kannada glossary</a>
            <a href="about.html">About</a>
            <a href="https://alar.ink">Alar</a>
        </div>
        <div style="margin-top: 20px; font-size: 12px; color: #999;">
            Made with ‚ù§Ô∏è by <a href="https://github.com/pvnkmrksk" target="_blank" style="color: #000; text-decoration: underline;">pvnkmrksk</a>
        </div>
    </footer>

    <script>
        // Main App
        const YAML_URL = 'https://raw.githubusercontent.com/alar-dict/data/master/alar.yml';
        const DATAMUSE_API = 'https://api.datamuse.com/words';
        const CACHE_KEY = 'rala_dictionary_cache';
        const CACHE_VERSION_KEY = 'rala_cache_version';
        const CACHE_VERSION = '1.0'; // Increment this to invalidate all caches
        const DB_NAME = 'rala_dictionary_db';
        const DB_VERSION = 1;
        const STORE_NAME = 'dictionary';
        
        let dictionary = [];
        let reverseIndex = new Map();
        let allEnglishWords = new Set();
        
        // Cache for audio file existence checks
        const audioExistenceCache = new Map(); // entryId -> boolean (true/false/null for unknown)
        
        // DOM elements
        const app = document.getElementById('app');
        
        // Initialize
        async function init() {
            try {
                await loadDictionary();
                buildReverseIndex();
                renderApp();
            } catch (error) {
                app.innerHTML = `
                    <div class="status" style="color: #e74c3c;">
                        <p>‚ùå Failed to load dictionary: ${error.message}</p>
                        <p style="font-size: 14px;">Try refreshing the page or check your internet connection.</p>
                    </div>
                `;
            }
        }
        
        // IndexedDB helper functions
        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                };
            });
        }
        
        async function getCachedDictionary() {
            try {
                const db = await openDB();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.get('dictionary');
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve(request.result);
                });
            } catch (error) {
                console.warn('IndexedDB not available:', error);
                return null;
            }
        }
        
        async function setCachedDictionary(data) {
            try {
                const db = await openDB();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.put(data, 'dictionary');
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve();
                });
            } catch (error) {
                console.error('Failed to save to IndexedDB:', error);
                throw error;
            }
        }
        
        async function getCachedVersion() {
            try {
                const db = await openDB();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.get('version');
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve(request.result);
                });
            } catch (error) {
                return null;
            }
        }
        
        async function setCachedVersion(version) {
            try {
                const db = await openDB();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.put(version, 'version');
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve();
                });
            } catch (error) {
                console.error('Failed to save version to IndexedDB:', error);
            }
        }
        
        // Check if URL has refresh parameter (for hard refresh bypass)
        function shouldBypassCache() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.has('refresh') || urlParams.has('nocache');
        }
        
        // Load dictionary with IndexedDB caching
        async function loadDictionary() {
            // Check if we should bypass cache (URL parameter or version mismatch)
            const bypassCache = shouldBypassCache();
            const cachedVersion = await getCachedVersion();
            const versionMatches = cachedVersion === CACHE_VERSION;
            
            // Try to load from cache first (unless bypassed or version mismatch)
            if (!bypassCache && versionMatches) {
                try {
                    const cachedData = await getCachedDictionary();
                    if (cachedData && Array.isArray(cachedData) && cachedData.length > 0) {
                        console.log(`‚úì Loaded ${cachedData.length} entries from IndexedDB cache`);
                        console.log('Using cached dictionary. Add ?refresh=true to URL to force reload from network.');
                        dictionary = cachedData;
                        return; // Use cache, don't fetch from network
                    } else {
                        console.log('No cache found in IndexedDB, fetching from network');
                    }
                } catch (error) {
                    console.warn('Failed to load from IndexedDB cache:', error);
                    console.log('Falling back to network fetch');
                }
            } else {
                if (bypassCache) {
                    console.log('Cache bypassed (refresh parameter detected)');
                } else if (!versionMatches) {
                    console.log(`Cache version mismatch (cached: ${cachedVersion}, current: ${CACHE_VERSION}), fetching fresh data`);
                }
            }
            
            // If no cache or bypassed, fetch from network
            await fetchAndCacheDictionary();
        }
        
        // Fetch dictionary from network and cache it in IndexedDB
        async function fetchAndCacheDictionary() {
            try {
                console.log('Fetching dictionary from network...');
                const response = await fetch(YAML_URL);
                if (!response.ok) throw new Error('Failed to fetch dictionary');
                const text = await response.text();
                dictionary = jsyaml.load(text);
                console.log(`‚úì Loaded ${dictionary.length} entries from network`);
                
                // Cache the parsed dictionary in IndexedDB
                try {
                    const dataSize = new Blob([JSON.stringify(dictionary)]).size;
                    const sizeMB = (dataSize / 1024 / 1024).toFixed(2);
                    console.log(`Caching ${sizeMB} MB of data in IndexedDB...`);
                    
                    await setCachedDictionary(dictionary);
                    await setCachedVersion(CACHE_VERSION);
                    
                    // Verify cache was saved
                    const verifyCache = await getCachedDictionary();
                    if (verifyCache && verifyCache.length === dictionary.length) {
                        console.log(`‚úì Dictionary cached successfully in IndexedDB (${sizeMB} MB)`);
                        console.log(`  Cache verification: ${verifyCache.length} entries stored`);
                    } else {
                        console.warn('‚ö† Cache verification: entry count mismatch');
                    }
                } catch (error) {
                    console.error('‚úó Failed to cache dictionary in IndexedDB:', error);
                    console.error('Dictionary will be fetched on each visit');
                }
            } catch (error) {
                // If network fetch fails and we have cached data, use it
                if (dictionary.length === 0) {
                    try {
                        const cachedData = await getCachedDictionary();
                        if (cachedData && Array.isArray(cachedData) && cachedData.length > 0) {
                            dictionary = cachedData;
                            console.log(`‚úì Network failed, using cached data: ${dictionary.length} entries`);
                            return;
                        }
                    } catch (cacheError) {
                        console.error('‚úó Failed to load from cache:', cacheError);
                    }
                }
                throw error;
            }
        }
        
        // Function to manually clear cache (can be called from console: clearRalaCache())
        async function clearRalaCache() {
            try {
                const db = await openDB();
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                await Promise.all([
                    new Promise((resolve, reject) => {
                        const req = store.delete('dictionary');
                        req.onsuccess = () => resolve();
                        req.onerror = () => reject(req.error);
                    }),
                    new Promise((resolve, reject) => {
                        const req = store.delete('version');
                        req.onsuccess = () => resolve();
                        req.onerror = () => reject(req.error);
                    })
                ]);
                console.log('‚úì Rala cache cleared from IndexedDB. Refresh the page to reload from network.');
            } catch (error) {
                console.error('Failed to clear cache:', error);
                // Fallback: try to delete the entire database
                try {
                    const deleteReq = indexedDB.deleteDatabase(DB_NAME);
                    deleteReq.onsuccess = () => {
                        console.log('‚úì Database deleted. Refresh the page to reload from network.');
                    };
                    deleteReq.onerror = () => {
                        console.error('Failed to delete database:', deleteReq.error);
                    };
                } catch (dbError) {
                    console.error('Failed to delete database:', dbError);
                }
            }
        }
        
        // Function to check cache status (can be called from console: checkRalaCache())
        async function checkRalaCache() {
            try {
                const cachedData = await getCachedDictionary();
                const version = await getCachedVersion();
                
                if (cachedData && Array.isArray(cachedData)) {
                    const size = new Blob([JSON.stringify(cachedData)]).size;
                    console.log('Cache Status (IndexedDB):');
                    console.log(`  Version: ${version} (current: ${CACHE_VERSION})`);
                    console.log(`  Entries: ${cachedData.length}`);
                    console.log(`  Size: ${(size / 1024 / 1024).toFixed(2)} MB`);
                    console.log(`  Valid: ${cachedData.length > 0 ? 'Yes' : 'No'}`);
                } else {
                    console.log('Cache Status: No cache found in IndexedDB');
                }
            } catch (error) {
                console.log('Cache Status: Error checking cache -', error.message);
            }
        }
        
        // Make cache functions available globally
        window.clearRalaCache = clearRalaCache;
        window.checkRalaCache = checkRalaCache;
        
        function buildReverseIndex() {
            // Build reverse index: English word -> list of Kannada entries
            reverseIndex = new Map();
            
            for (let i = 0; i < dictionary.length; i++) {
                const entry = dictionary[i];
                if (!entry.defs) continue;
                
                // Use the entry's own ID field (which matches the voice corpus file IDs)
                const entryId = entry.id;
                
                for (const def of entry.defs) {
                    if (!def.entry) continue;
                    
                    // Extract English words from definition
                    const words = extractWords(def.entry.toLowerCase());
                    
                    for (const word of words) {
                        allEnglishWords.add(word);
                        if (!reverseIndex.has(word)) {
                            reverseIndex.set(word, []);
                        }
                        reverseIndex.get(word).push({
                            kannada: entry.entry,
                            phone: entry.phone,
                            definition: def.entry,
                            type: def.type,
                            head: entry.head,
                            id: entryId
                        });
                    }
                }
            }
            
            console.log(`Built reverse index with ${reverseIndex.size} English words`);
        }
        
        function extractWords(text) {
            // Extract meaningful words (skip common words, punctuation, etc.)
            const stopWords = new Set([
                'a', 'an', 'the', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
                'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could',
                'should', 'may', 'might', 'must', 'shall', 'can', 'need', 'dare',
                'to', 'of', 'in', 'for', 'on', 'with', 'at', 'by', 'from', 'up',
                'about', 'into', 'over', 'after', 'or', 'and', 'but', 'if', 'as',
                'etc', 'eg', 'ie', 'cf', 'vs', 'fig', 'esp', 'also', 'see'
            ]);
            
            return text
                .replace(/[^\w\s-]/g, ' ')
                .split(/\s+/)
                .filter(w => w.length > 2 && !stopWords.has(w) && !/^\d+$/.test(w));
        }
        
        async function getSynonyms(word) {
            try {
                // Get synonyms using Datamuse API
                const response = await fetch(`${DATAMUSE_API}?rel_syn=${encodeURIComponent(word)}&max=15`);
                const data = await response.json();
                return data.map(item => item.word);
            } catch {
                return [];
            }
        }
        
        async function getSimilarWords(word) {
            try {
                // Get words with similar meaning
                const response = await fetch(`${DATAMUSE_API}?ml=${encodeURIComponent(word)}&max=20`);
                const data = await response.json();
                return data.map(item => item.word);
            } catch {
                return [];
            }
        }
        
        function isExactDefinition(definition) {
            // Check if definition ends with "; a ..." or "; an ..." pattern
            // These are primary/exact definitions
            // Pattern examples: "; a printer." or "; an editor."
            if (!definition) return false;
            const trimmed = definition.trim();
            // Match "; a " or "; an " followed by any text ending with period
            // More permissive: check if it contains "; a " or "; an " in the last 100 chars
            const lastPart = trimmed.slice(-100);
            return /;\s*(a|an)\s+[^;]+\.\s*$/i.test(lastPart);
        }
        
        function getDefinitionPriority(definition, searchWord) {
            // Higher priority = comes first
            // Priority 1: Ends with "; a [searchWord]" or "; an [searchWord]" (exact match)
            // Priority 2: Ends with "; a ..." or "; an ..." (any exact definition)
            // Priority 3: Other definitions
            
            if (!definition) return 3;
            const trimmed = definition.trim().toLowerCase();
            const searchLower = searchWord.toLowerCase();
            
            // Check if it ends with exact match: "; a editor." or "; an editor."
            const exactMatchPattern = new RegExp(`;\\s*(a|an)\\s+${searchLower.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\.\\s*$`, 'i');
            if (exactMatchPattern.test(trimmed)) {
                return 1; // Highest priority
            }
            
            // Check if it's an exact definition (ends with "; a ..." or "; an ...")
            if (isExactDefinition(definition)) {
                return 2; // Second priority
            }
            
            return 3; // Lowest priority
        }
        
        function searchDirect(query) {
            const words = query.toLowerCase().split(/\s+/).filter(w => w.length > 0);
            const results = [];
            const seen = new Set();
            
            for (const word of words) {
                if (reverseIndex.has(word)) {
                    for (const entry of reverseIndex.get(word)) {
                        const key = `${entry.kannada}-${entry.definition}`;
                        if (!seen.has(key)) {
                            seen.add(key);
                            results.push({ ...entry, matchedWord: word, matchType: 'direct' });
                        }
                    }
                }
            }
            
            // Sort results: prioritize exact definitions, especially those matching the search term
            const exactCount = results.filter(r => isExactDefinition(r.definition)).length;
            console.log(`Direct search - Total: ${results.length}, Exact definitions: ${exactCount}`);
            
            results.sort((a, b) => {
                // Get priority for each result (using the matched word as search term)
                const aPriority = getDefinitionPriority(a.definition, a.matchedWord);
                const bPriority = getDefinitionPriority(b.definition, b.matchedWord);
                
                // Lower priority number = higher priority (comes first)
                if (aPriority !== bPriority) {
                    return aPriority - bPriority;
                }
                
                // If same priority, keep original order
                return 0;
            });
            
            return results;
        }
        
        async function searchWithSynonyms(query) {
            const words = query.toLowerCase().split(/\s+/).filter(w => w.length > 0);
            const results = [];
            const seen = new Set();
            const synonymsUsed = {};
            
            for (const word of words) {
                // Get synonyms and similar words
                const [synonyms, similar] = await Promise.all([
                    getSynonyms(word),
                    getSimilarWords(word)
                ]);
                
                const relatedWords = [...new Set([...synonyms, ...similar])];
                
                for (const relWord of relatedWords) {
                    if (reverseIndex.has(relWord)) {
                        for (const entry of reverseIndex.get(relWord)) {
                            const key = `${entry.kannada}-${entry.definition}`;
                            if (!seen.has(key)) {
                                seen.add(key);
                                if (!synonymsUsed[word]) synonymsUsed[word] = [];
                                if (!synonymsUsed[word].includes(relWord)) {
                                    synonymsUsed[word].push(relWord);
                                }
                                results.push({ 
                                    ...entry, 
                                    matchedWord: relWord, 
                                    originalQuery: word,
                                    matchType: 'synonym' 
                                });
                            }
                        }
                    }
                }
            }
            
            // Sort results: prioritize exact definitions, especially those matching the search term
            const exactCount = results.filter(r => isExactDefinition(r.definition)).length;
            console.log(`Synonym search - Total: ${results.length}, Exact definitions: ${exactCount}`);
            
            results.sort((a, b) => {
                // Get priority for each result (using the matched word as search term)
                const aPriority = getDefinitionPriority(a.definition, a.matchedWord);
                const bPriority = getDefinitionPriority(b.definition, b.matchedWord);
                
                // Lower priority number = higher priority (comes first)
                if (aPriority !== bPriority) {
                    return aPriority - bPriority;
                }
                
                // If same priority, keep original order
                return 0;
            });
            
            return { results, synonymsUsed };
        }
        
        function highlightMatch(text, word) {
            const regex = new RegExp(`\\b(${word})\\b`, 'gi');
            return text.replace(regex, '<span class="matched-word">$1</span>');
        }
        
        function renderResults(directResults, synonymResults, synonymsUsed, query, loadingDirect = false, loadingIndirect = false) {
            let html = '';
            
            if (directResults.length === 0 && synonymResults.length === 0 && !loadingDirect && !loadingIndirect) {
                return `
                    <div class="no-results">
                        <p>No results found for "${query}"</p>
                        <p style="font-size: 14px; margin-top: 8px;">Try a different word or check spelling</p>
                    </div>
                `;
            }
            
            // Exact matches section
            html += `
                <div class="results-section section-anchor" id="exact-matches">
                    <div class="section-header">Exact Match${directResults.length !== 1 ? 'es' : ''} (${directResults.length})</div>
            `;
            
            if (loadingDirect) {
                html += `
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Searching...</p>
                    </div>
                `;
            } else if (directResults.length > 0) {
                html += directResults.map(r => renderResultCard(r, query)).join('');
                // Check audio files and update buttons after rendering
                setTimeout(() => checkAndUpdateAudioButtons(directResults), 100);
            } else {
                html += `
                    <div class="no-results">
                        <p>No exact matches found</p>
                    </div>
                `;
            }
            
            html += `</div>`;
            
            // Synonym matches section
            html += `
                <div class="results-section section-anchor" id="synonym-matches">
                    <div class="section-header">Synonym Match${synonymResults.length !== 1 ? 'es' : ''} (${synonymResults.length})</div>
            `;
            
            if (loadingIndirect) {
                html += `
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Searching...</p>
                    </div>
                `;
            } else if (synonymResults.length > 0) {
                const usedSynonyms = Object.entries(synonymsUsed)
                    .map(([orig, syns]) => `"${orig}" ‚Üí ${syns.slice(0, 5).join(', ')}`)
                    .join('; ');
                    
                html += `
                    <div class="search-info">
                        Found via: ${usedSynonyms}
                    </div>
                `;
                html += synonymResults.map(r => renderResultCard(r, query, true)).join('');
                // Check audio files and update buttons after rendering
                setTimeout(() => checkAndUpdateAudioButtons(synonymResults), 100);
            } else if (!loadingDirect) {
                html += `
                    <div class="no-results">
                        <p>No synonym matches found</p>
                    </div>
                `;
            }
            
            html += `</div>`;
            
            return html;
        }
        
        function getAudioUrl(entryId) {
            if (!entryId) return null;
            // Audio files are organized by ID ranges: 1-9999, 10000-19999, etc.
            // Range calculation: for ID 1-9999 use "1-9999", for 10000-19999 use "10000-19999", etc.
            // For IDs 1-9999: rangeStart = 1, rangeEnd = 9999
            // For IDs 10000-19999: rangeStart = 10000, rangeEnd = 19999
            // For IDs 20000-29999: rangeStart = 20000, rangeEnd = 29999, etc.
            let rangeStart, rangeEnd;
            if (entryId <= 9999) {
                rangeStart = 1;
                rangeEnd = 9999;
            } else {
                rangeStart = Math.floor(entryId / 10000) * 10000;
                rangeEnd = rangeStart + 9999;
            }
            const range = `${rangeStart}-${rangeEnd}`;
            // Using raw.githubusercontent.com to serve the audio files
            return `https://raw.githubusercontent.com/Aditya-ds-1806/Alar-voice-corpus/main/audio/${range}/${entryId}.mp3`;
        }
        
        async function checkAudioExists(entryId) {
            if (!entryId) return false;
            
            // Check cache first
            if (audioExistenceCache.has(entryId)) {
                return audioExistenceCache.get(entryId);
            }
            
            const audioUrl = getAudioUrl(entryId);
            if (!audioUrl) {
                audioExistenceCache.set(entryId, false);
                return false;
            }
            
            try {
                // Use HEAD request to check if file exists without downloading it
                const response = await fetch(audioUrl, { method: 'HEAD', cache: 'no-cache' });
                const exists = response.ok && response.status === 200;
                audioExistenceCache.set(entryId, exists);
                
                if (!exists) {
                    console.log(`Audio file not found for entry ID ${entryId}: ${audioUrl}`);
                }
                
                return exists;
            } catch (error) {
                // If there's an error (network, CORS, etc.), assume it doesn't exist
                audioExistenceCache.set(entryId, false);
                console.log(`Error checking audio for entry ID ${entryId}:`, error);
                return false;
            }
        }
        
        async function checkAndUpdateAudioButtons(results) {
            // Collect all unique entry IDs from results that we haven't checked yet
            const entryIds = [...new Set(results.map(r => r.id).filter(id => id && !audioExistenceCache.has(id)))];
            
            if (entryIds.length === 0) return; // All already checked
            
            // Check all audio files in parallel (limit to avoid too many requests)
            const checkPromises = entryIds.slice(0, 50).map(async (entryId) => {
                const exists = await checkAudioExists(entryId);
                return { entryId, exists };
            });
            
            const results_checks = await Promise.all(checkPromises);
            
            // Update buttons based on existence
            results_checks.forEach(({ entryId, exists }) => {
                // Find all buttons for this entry ID
                const buttons = document.querySelectorAll(`[data-entry-id="${entryId}"]`);
                if (buttons.length === 0 && exists) {
                    // Button wasn't shown but file exists - we need to add it
                    // This shouldn't happen with current logic, but handle it just in case
                    return;
                }
                buttons.forEach(button => {
                    if (exists) {
                        button.style.display = '';
                    } else {
                        // Remove the button if it doesn't exist
                        button.remove();
                    }
                });
            });
        }
        
        function renderResultCard(result, query, isSynonym = false) {
            const highlightedDef = highlightMatch(result.definition, result.matchedWord);
            const audioUrl = result.id ? getAudioUrl(result.id) : null;
            const audioId = `audio-${result.id || 'no-id'}-${result.kannada.replace(/[^a-zA-Z0-9]/g, '-')}`;
            
            // Check cache first - if we know it doesn't exist, don't show button
            // If unknown, show it and check asynchronously
            let showButton = false;
            if (audioUrl && result.id) {
                const cached = audioExistenceCache.get(result.id);
                if (cached === true) {
                    showButton = true; // We know it exists
                } else if (cached === false) {
                    showButton = false; // We know it doesn't exist
                } else {
                    showButton = true; // Unknown - show it and check later
                }
            }
            
            return `
                <div class="result-card">
                    <div class="kannada-word">
                        ${showButton && audioUrl ? `
                            <button class="audio-button" id="${audioId}" data-entry-id="${result.id || ''}" onclick="playAudio('${audioId}', '${audioUrl.replace(/'/g, "\\'")}')" title="Play pronunciation">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M8 5v14l11-7z"/>
                                </svg>
                            </button>
                        ` : ''}
                        <span>${result.kannada}</span>
                    </div>
                    <div class="phonetic">${result.phone || ''}</div>
                    <div class="definition">
                        <span class="def-type">${result.type || 'n/a'}</span>
                        <span class="def-text">${highlightedDef}</span>
                    </div>
                    ${isSynonym ? `<div class="synonym-match">matched via synonym: "${result.matchedWord}" (searched: "${result.originalQuery}")</div>` : ''}
                </div>
            `;
        }
        
        function playAudio(buttonId, audioUrl) {
            const button = document.getElementById(buttonId);
            if (!button) return;
            
            // Stop any currently playing audio
            const currentAudio = window.currentPlayingAudio;
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                const prevButton = document.querySelector('.audio-button.playing');
                if (prevButton) prevButton.classList.remove('playing');
            }
            
            // Play new audio
            const audio = new Audio(audioUrl);
            window.currentPlayingAudio = audio;
            
            button.classList.add('playing');
            
            audio.play().catch(err => {
                console.error('Error playing audio:', err);
                button.classList.remove('playing');
            });
            
            audio.onended = () => {
                button.classList.remove('playing');
                window.currentPlayingAudio = null;
            };
            
            audio.onerror = () => {
                button.classList.remove('playing');
                window.currentPlayingAudio = null;
            };
        }
        
        // Make playAudio available globally
        window.playAudio = playAudio;
        
        function renderApp() {
            app.innerHTML = `
                <div class="tabs-wrapper" id="tabs-wrapper" style="display: none;">
                    <div class="tabs">
                        <button class="tab active" id="tab-exact">
                            <span>Exact Match</span>
                            <span id="tab-exact-count"></span>
                            <span id="tab-exact-spinner" class="tab-spinner" style="display: none;"></span>
                        </button>
                        <button class="tab" id="tab-synonym">
                            <span>Synonym Match</span>
                            <span id="tab-synonym-count"></span>
                            <span id="tab-synonym-spinner" class="tab-spinner" style="display: none;"></span>
                        </button>
                    </div>
                </div>
                <div id="results" class="results-container"></div>
                <div class="stats">
                    ${dictionary.length.toLocaleString()} Kannada entries | 
                    ${reverseIndex.size.toLocaleString()} unique English words indexed
                </div>
            `;
            
            const searchInput = document.getElementById('search-input');
            const searchButton = document.getElementById('search-button');
            const resultsDiv = document.getElementById('results');
            const tabsWrapper = document.getElementById('tabs-wrapper');
            const tabExact = document.getElementById('tab-exact');
            const tabSynonym = document.getElementById('tab-synonym');
            const tabExactCount = document.getElementById('tab-exact-count');
            const tabSynonymCount = document.getElementById('tab-synonym-count');
            const tabExactSpinner = document.getElementById('tab-exact-spinner');
            const tabSynonymSpinner = document.getElementById('tab-synonym-spinner');
            
            let directResults = [];
            let synonymResults = [];
            let synonymsUsed = {};
            let currentQuery = '';
            let debounceTimer = null;
            let synonymSearchInProgress = false;
            let synonymSearchCompleted = false;
            let synonymSearchTimeout = null;
            
            function switchTab(tabName) {
                if (tabName === 'exact') {
                    tabExact.classList.add('active');
                    tabSynonym.classList.remove('active');
                    const exactSection = document.getElementById('exact-matches');
                    if (exactSection) {
                        setTimeout(() => {
                            const searchHeight = document.querySelector('.sticky-search').offsetHeight;
                            const tabsHeight = document.querySelector('.tabs-wrapper').offsetHeight;
                            const offset = searchHeight + tabsHeight;
                            const elementPosition = exactSection.getBoundingClientRect().top + window.pageYOffset;
                            window.scrollTo({ 
                                top: elementPosition - offset, 
                                behavior: 'smooth' 
                            });
                        }, 100);
                    }
                } else {
                    tabSynonym.classList.add('active');
                    tabExact.classList.remove('active');
                    const synonymSection = document.getElementById('synonym-matches');
                    if (synonymSection) {
                        setTimeout(() => {
                            const searchHeight = document.querySelector('.sticky-search').offsetHeight;
                            const tabsHeight = document.querySelector('.tabs-wrapper').offsetHeight;
                            const offset = searchHeight + tabsHeight;
                            const elementPosition = synonymSection.getBoundingClientRect().top + window.pageYOffset;
                            window.scrollTo({ 
                                top: elementPosition - offset, 
                                behavior: 'smooth' 
                            });
                        }, 100);
                    }
                }
            }
            
            tabExact.addEventListener('click', () => switchTab('exact'));
            tabSynonym.addEventListener('click', () => switchTab('synonym'));
            searchButton.addEventListener('click', () => {
                if (searchInput.value.trim()) {
                    performSearch(searchInput.value.trim(), true);
                }
            });
            
            async function loadSynonyms(query) {
                if (synonymSearchInProgress || synonymSearchCompleted) {
                    return;
                }
                
                synonymSearchInProgress = true;
                tabSynonymSpinner.style.display = 'inline-block';
                
                const { results: synonymResultsTemp, synonymsUsed: synonymsUsedTemp } = await searchWithSynonyms(query);
                
                // Filter out synonym results that are already in direct results
                const directKeys = new Set(directResults.map(r => `${r.kannada}-${r.definition}`));
                synonymResults = synonymResultsTemp.filter(r => 
                    !directKeys.has(`${r.kannada}-${r.definition}`)
                );
                synonymsUsed = synonymsUsedTemp;
                
                tabSynonymCount.textContent = ` (${synonymResults.length})`;
                tabSynonymSpinner.style.display = 'none';
                synonymSearchCompleted = true;
                
                // Update UI with both results
                resultsDiv.innerHTML = renderResults(directResults, synonymResults, synonymsUsed, query, false, false);
            }
            
            async function performSearch(query, fromEnter = false) {
                if (!query.trim()) {
                    resultsDiv.innerHTML = '';
                    tabsWrapper.style.display = 'none';
                    directResults = [];
                    synonymResults = [];
                    synonymsUsed = {};
                    currentQuery = '';
                    synonymSearchInProgress = false;
                    synonymSearchCompleted = false;
                    if (synonymSearchTimeout) {
                        clearTimeout(synonymSearchTimeout);
                        synonymSearchTimeout = null;
                    }
                    return;
                }
                
                currentQuery = query;
                directResults = [];
                synonymResults = [];
                synonymsUsed = {};
                synonymSearchInProgress = false;
                synonymSearchCompleted = false;
                
                // Clear any pending synonym search
                if (synonymSearchTimeout) {
                    clearTimeout(synonymSearchTimeout);
                    synonymSearchTimeout = null;
                }
                
                // Show tabs
                tabsWrapper.style.display = 'block';
                
                // Reset tab states
                tabExactCount.textContent = '';
                tabSynonymCount.textContent = '';
                tabExactSpinner.style.display = 'inline-block';
                tabSynonymSpinner.style.display = 'none';
                
                // Show loading state for direct matches
                resultsDiv.innerHTML = renderResults([], [], {}, query, true, false);
                switchTab('exact');
                
                // Step 1: Search direct matches
                directResults = searchDirect(query);
                tabExactCount.textContent = ` (${directResults.length})`;
                tabExactSpinner.style.display = 'none';
                
                // Update UI with direct results
                resultsDiv.innerHTML = renderResults(directResults, [], {}, query, false, false);
                
                // Step 2: Load synonyms with delay (500ms) or immediately if Enter was pressed
                if (fromEnter) {
                    // Load immediately if Enter was pressed
                    await loadSynonyms(query);
                } else {
                    // Wait 500ms before loading synonyms
                    synonymSearchTimeout = setTimeout(() => {
                        loadSynonyms(query);
                    }, 500);
                }
                
                // Hide tabs if no results at all
                if (directResults.length === 0 && synonymResults.length === 0) {
                    tabsWrapper.style.display = 'none';
                } else {
                    // Default to exact tab
                    switchTab('exact');
                }
            }
            
            searchInput.addEventListener('input', (e) => {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    performSearch(e.target.value, false);
                }, 300);
            });
            
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    clearTimeout(debounceTimer);
                    const query = e.target.value.trim();
                    
                    // If query changed, perform new search
                    if (query !== currentQuery) {
                        performSearch(query, true);
                    } else if (!synonymSearchCompleted && !synonymSearchInProgress && currentQuery) {
                        // If synonyms haven't loaded yet, load them now
                        if (synonymSearchTimeout) {
                            clearTimeout(synonymSearchTimeout);
                            synonymSearchTimeout = null;
                        }
                        loadSynonyms(currentQuery);
                    }
                }
            });
        }
        
        // Service Worker Registration for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('service-worker.js')
                    .then((registration) => {
                        console.log('‚úì Service Worker registered:', registration.scope);
                        
                        // Check for updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    console.log('New service worker available. Refresh to update.');
                                }
                            });
                        });
                    })
                    .catch((error) => {
                        console.warn('Service Worker registration failed:', error);
                    });
            });
        }
        
        // Install Prompt Handling
        let deferredPrompt;
        const installPrompt = document.getElementById('install-prompt');
        const installClose = document.getElementById('install-close');
        
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent the mini-infobar from appearing
            e.preventDefault();
            // Stash the event so it can be triggered later
            deferredPrompt = e;
            // Show the install prompt
            installPrompt.classList.add('show');
        });
        
        installPrompt.addEventListener('click', async () => {
            if (!deferredPrompt) return;
            
            // Show the install prompt
            deferredPrompt.prompt();
            
            // Wait for the user to respond
            const { outcome } = await deferredPrompt.userChoice;
            console.log(`User response to install prompt: ${outcome}`);
            
            // Clear the deferredPrompt
            deferredPrompt = null;
            
            // Hide the install prompt
            installPrompt.classList.remove('show');
        });
        
        installClose.addEventListener('click', (e) => {
            e.stopPropagation();
            installPrompt.classList.remove('show');
        });
        
        // Hide prompt if app is already installed
        window.addEventListener('appinstalled', () => {
            console.log('PWA installed successfully');
            installPrompt.classList.remove('show');
            deferredPrompt = null;
        });
        
        // Check if app is already installed (standalone mode)
        if (window.matchMedia('(display-mode: standalone)').matches || 
            window.navigator.standalone === true) {
            console.log('Running as installed PWA');
            installPrompt.classList.remove('show');
        }
        
        // PWA Info Banner
        const pwaInfoBanner = document.getElementById('pwa-info-banner');
        const pwaInfoDismiss = document.getElementById('pwa-info-dismiss');
        
        // Show info banner on first visit (if not dismissed before)
        function showPWAInfo() {
            const dismissed = localStorage.getItem('pwa-info-dismissed');
            const isInstalled = window.matchMedia('(display-mode: standalone)').matches || 
                               window.navigator.standalone === true;
            
            // Don't show if already dismissed or already installed
            if (!dismissed && !isInstalled && pwaInfoBanner) {
                // Show after a short delay so page loads first
                setTimeout(() => {
                    pwaInfoBanner.classList.add('show');
                }, 2000);
            }
        }
        
        // Dismiss banner
        if (pwaInfoDismiss) {
            pwaInfoDismiss.addEventListener('click', () => {
                if (pwaInfoBanner) {
                    pwaInfoBanner.classList.remove('show');
                    localStorage.setItem('pwa-info-dismissed', 'true');
                }
            });
        }
        
        // Show info banner
        showPWAInfo();
        
        // Start the app
        init();
    </script>
</body>
</html>
